<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A self create Algorithm to link nodes in ARKit</title>
    <url>/2020/04/27/A-self-create-Algorithm-to-link-nodes-in-ARKit/</url>
    <content><![CDATA[<hr>
<p>这是我瞎发明的SCNCylinder链接ARkit或者Scenekit中两个节点的小算法，因为SCNCylinder不能设置起始位置和结束位置，只能通过三角函数自己旋转，下面代码需要的直接CV就好了</p>
<span id="more"></span>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">linkTwoNodes</span>(<span class="keyword">_</span> <span class="params">node1</span>: <span class="type">SCNNode</span>, <span class="keyword">_</span> <span class="params">node2</span>: <span class="type">SCNNode</span>, <span class="keyword">_</span> <span class="params">lineNode</span>: <span class="type">SCNNode</span>, <span class="keyword">_</span> <span class="params">line</span>: <span class="type">SCNCylinder</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> p1 <span class="operator">=</span> node1.position</span><br><span class="line">        <span class="keyword">let</span> p2 <span class="operator">=</span> node2.position</span><br><span class="line">        <span class="keyword">let</span> dx <span class="operator">=</span> p1.x <span class="operator">-</span> p2.x</span><br><span class="line">        <span class="keyword">let</span> dy <span class="operator">=</span> p1.y <span class="operator">-</span> p2.y</span><br><span class="line">        <span class="keyword">let</span> dz <span class="operator">=</span> p1.z <span class="operator">-</span> p2.z</span><br><span class="line">       </span><br><span class="line">        line.height <span class="operator">=</span> get3dDis(node1.position, node2.position)</span><br><span class="line">       </span><br><span class="line">        lineNode.position <span class="operator">=</span> <span class="type">SCNVector3</span>((p1.x<span class="operator">+</span>p2.x)<span class="operator">/</span><span class="number">2</span>, (p1.y<span class="operator">+</span>p2.y)<span class="operator">/</span><span class="number">2</span>, (p1.z<span class="operator">+</span>p2.z)<span class="operator">/</span><span class="number">2</span>)</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">var</span> rotateX: <span class="type">Float</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> rotateZ: <span class="type">Float</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">let</span> crossLen:<span class="type">Float</span> <span class="operator">=</span> <span class="type">Float</span>(<span class="built_in">abs</span>(sqrt(pow(dx, <span class="number">2</span>) <span class="operator">+</span> pow(dy, <span class="number">2</span>))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dx <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateZ <span class="operator">=</span> <span class="operator">-</span>atanRotation(len1: dx, len2: dy)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dx <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateZ <span class="operator">=</span> atanRotation(len1: <span class="operator">-</span>dx, len2: dy)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dx <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateZ <span class="operator">=</span> <span class="operator">-</span>atanRotation(len1: <span class="operator">-</span>dx, len2: <span class="operator">-</span>dy)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dx <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateZ <span class="operator">=</span> atanRotation(len1: dx, len2: <span class="operator">-</span>dy)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateZ <span class="operator">=</span> <span class="type">Float</span>.pi <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dz <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateX <span class="operator">=</span> <span class="operator">-</span>atanRotation(len1: <span class="operator">-</span>dz, len2: crossLen)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dz <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateX <span class="operator">=</span> atanRotation(len1: dz, len2: crossLen)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dz <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateX <span class="operator">=</span> <span class="operator">-</span>atanRotation(len1: dz, len2: crossLen)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dz <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateX <span class="operator">=</span> atanRotation(len1: <span class="operator">-</span>dz, len2: crossLen)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">//mod</span></span><br><span class="line">            <span class="keyword">if</span> dz <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">                rotateX <span class="operator">=</span> <span class="type">Float</span>.pi <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lineNode.eulerAngles.x <span class="operator">=</span> <span class="type">Float</span>(rotateX)</span><br><span class="line">        lineNode.eulerAngles.z <span class="operator">=</span> <span class="type">Float</span>(rotateZ)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">linkTwoNodes</span>(<span class="keyword">_</span> <span class="params">node1</span>: <span class="type">SCNNode</span>, <span class="keyword">_</span> <span class="params">node2</span>: <span class="type">SCNNode</span>, <span class="keyword">_</span> <span class="params">lineNode</span>: <span class="type">SCNNode</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> p1 <span class="operator">=</span> node1.position</span><br><span class="line">        <span class="keyword">let</span> p2 <span class="operator">=</span> node2.position</span><br><span class="line">        <span class="keyword">let</span> dx <span class="operator">=</span> p1.x <span class="operator">-</span> p2.x</span><br><span class="line">        <span class="keyword">let</span> dy <span class="operator">=</span> p1.y <span class="operator">-</span> p2.y</span><br><span class="line">        <span class="keyword">let</span> dz <span class="operator">=</span> p1.z <span class="operator">-</span> p2.z</span><br><span class="line">       </span><br><span class="line">        lineNode.position <span class="operator">=</span> <span class="type">SCNVector3</span>((p1.x<span class="operator">+</span>p2.x)<span class="operator">/</span><span class="number">2</span>, (p1.y<span class="operator">+</span>p2.y)<span class="operator">/</span><span class="number">2</span>, (p1.z<span class="operator">+</span>p2.z)<span class="operator">/</span><span class="number">2</span>)</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">var</span> rotateX: <span class="type">Float</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> rotateZ: <span class="type">Float</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">let</span> crossLen:<span class="type">Float</span> <span class="operator">=</span> <span class="type">Float</span>(<span class="built_in">abs</span>(sqrt(pow(dx, <span class="number">2</span>) <span class="operator">+</span> pow(dy, <span class="number">2</span>))))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dx <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateZ <span class="operator">=</span> <span class="operator">-</span>atanRotation(len1: dx, len2: dy)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dx <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateZ <span class="operator">=</span> atanRotation(len1: <span class="operator">-</span>dx, len2: dy)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dx <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateZ <span class="operator">=</span> <span class="operator">-</span>atanRotation(len1: <span class="operator">-</span>dx, len2: <span class="operator">-</span>dy)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dx <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateZ <span class="operator">=</span> atanRotation(len1: dx, len2: <span class="operator">-</span>dy)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateZ <span class="operator">=</span> <span class="type">Float</span>.pi <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dz <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateX <span class="operator">=</span> <span class="operator">-</span>atanRotation(len1: <span class="operator">-</span>dz, len2: crossLen)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dz <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateX <span class="operator">=</span> atanRotation(len1: dz, len2: crossLen)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dz <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateX <span class="operator">=</span> <span class="operator">-</span>atanRotation(len1: dz, len2: crossLen)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> dz <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line">            rotateX <span class="operator">=</span> atanRotation(len1: <span class="operator">-</span>dz, len2: crossLen)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dy <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">//mod</span></span><br><span class="line">            <span class="keyword">if</span> dz <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">                rotateX <span class="operator">=</span> <span class="type">Float</span>.pi <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lineNode.eulerAngles.x <span class="operator">=</span> <span class="type">Float</span>(rotateX)</span><br><span class="line">        lineNode.eulerAngles.z <span class="operator">=</span> <span class="type">Float</span>(rotateZ)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">get3dDis</span>(<span class="keyword">_</span> <span class="params">p1</span>: <span class="type">SCNVector3</span>, <span class="keyword">_</span> <span class="params">p2</span>: <span class="type">SCNVector3</span>)</span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dx <span class="operator">=</span> p1.x <span class="operator">-</span> p2.x</span><br><span class="line">    <span class="keyword">let</span> dy <span class="operator">=</span> p1.y <span class="operator">-</span> p2.y</span><br><span class="line">    <span class="keyword">let</span> dz <span class="operator">=</span> p1.z <span class="operator">-</span> p2.z</span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGFloat</span>(<span class="built_in">abs</span>(sqrt(pow(dx, <span class="number">2</span>) <span class="operator">+</span> pow(dy, <span class="number">2</span>) <span class="operator">+</span> pow(dz, <span class="number">2</span>))))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">atanRotation</span>(<span class="params">len1</span>: <span class="type">Float</span>, <span class="params">len2</span>: <span class="type">Float</span>)</span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> len2 <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Float</span>.pi <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> len1 <span class="operator">==</span> <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> atan(len1 <span class="operator">/</span> len2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Definition for singly-linked list</title>
    <url>/2019/04/19/Definition-for-singly-linked-list/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="Definition-for-singly-linked-list"><a href="#Definition-for-singly-linked-list" class="headerlink" title="Definition for singly-linked list"></a>Definition for singly-linked list</h1><img src="/2019/04/19/Definition-for-singly-linked-list/list.png" class="" title="list">

<p>比方说有链表1:n1 n2 n3 n4<br>有链表2:n5 n3 n4<br>实际上n3和n4是同一个，也就是他们在n3时交叉的</p>
<p><img src="/Users/haoboxuxu/Desktop/blog-md/imgs/list.png" alt="list"></p>
<p>如果是分别遍历，复杂度是O(n2)，接下来介绍O(n)解法<br>假设长的链表为len1，短的为len2<br>那么把长的移动len1-len2<br>然后两个链表指针可以同时移动了，找到交叉的节点就返回，复杂度O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">(Node *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">listMove</span><span class="params">(Node*p, <span class="keyword">int</span> diff)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff; i++)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">findCommon</span><span class="params">(Node *l1, Node *l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">getLen</span>(l1);</span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="built_in">getLen</span>(l2);</span><br><span class="line">    Node *longListP, *shortListP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">        longListP = l1;</span><br><span class="line">        shortListP = l2;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        longListP = l2;</span><br><span class="line">        shortListP = l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> diff = <span class="built_in">abs</span>(len1 - len2);</span><br><span class="line">    longListP = <span class="built_in">listMove</span>(longListP, diff);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(longListP != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(longListP == shortListP)&#123;</span><br><span class="line">            <span class="keyword">return</span> longListP;</span><br><span class="line">        &#125;</span><br><span class="line">        longListP = longListP-&gt;next;</span><br><span class="line">        shortListP = shortListP-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node n1, n2, n3, n4, n5;</span><br><span class="line">    Node *l1 = &amp;n1, *l2 = &amp;n5;</span><br><span class="line">    n1.val = <span class="number">1</span>;</span><br><span class="line">    n2.val = <span class="number">2</span>;</span><br><span class="line">    n3.val = <span class="number">3</span>;</span><br><span class="line">    n4.val = <span class="number">4</span>;</span><br><span class="line">    n5.val = <span class="number">5</span>;</span><br><span class="line">    n1.next = &amp;n2;</span><br><span class="line">    n2.next = &amp;n3;</span><br><span class="line">    n3.next = &amp;n4;</span><br><span class="line">    n5.next = &amp;n3;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">findCommon</span>(l1, l2)-&gt;val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Elliptical Grid Mapping</title>
    <url>/2021/05/29/Elliptical-Grid-Mapping/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>最近看视频做RPG，有个有趣的问题，比如控制角色的走动时候用Dup和Dright两个变量，范围都是[-1, 1]，但是比如W键和D键同时按下时候算位移的Vector2时会有√2的问题，因为√(1+1)。<br>如果你考虑用clamp的话那么角色会很快加速过去了，这里有个论文讲Elliptical Grid Mapping，就是把一个正方形map到圆上，链接如下。</p>
<p>[论文URL]<a href="https://arxiv.org/ftp/arxiv/papers/1509/1509.06344.pdf">https://arxiv.org/ftp/arxiv/papers/1509/1509.06344.pdf</a></p>
<img src="/2021/05/29/Elliptical-Grid-Mapping/EllipticalGridMapping_1.jpg" class="" title="EllipticalGridMapping_1">

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Vector2 <span class="title">SquareToCircle</span>(<span class="params">Vector2 input</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector2 output = Vector2.zero;</span><br><span class="line">    <span class="comment">//公式如上图</span></span><br><span class="line">    output.x = input.x * Mathf.Sqrt(<span class="number">1</span> - (input.y * input.y) / <span class="number">2.0f</span>);</span><br><span class="line">    output.y = input.y * Mathf.Sqrt(<span class="number">1</span> - (input.x * input.x) / <span class="number">2.0f</span>);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Vector2 tempDAxis = SquareToCircle(<span class="keyword">new</span> Vector2(Dright, Dup)); <span class="comment">//Dright和Dup是控制角色移动的，上面提到了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> Dright2 = tempDAxis.y;</span><br><span class="line">    <span class="built_in">float</span> Dup2 = tempDAxis.x;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面就可以做其他的逻辑了</span></span><br><span class="line">    Dmag = Mathf.Sqrt((Dup2 * Dup2) + (Dright2 * Dright2));</span><br><span class="line">    Dvec = Dright2 * transform.right + Dup2 * transform.forward;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Jump Consistent Hash</title>
    <url>/2020/01/09/Jump-Consistent-Hash/</url>
    <content><![CDATA[<hr>
<p>大三一个课的小作业，做得小调研</p>
<span id="more"></span>

<p>Consistent Hash就是为了解决负载均衡的问题，如下图，把不同资源的访问分配的不同的服务器缓解压力；算法就是解决服务器和文件的映射</p>
<p>谈到映射就想到hash；如果你打过acm，就不得不说下面的哈希方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1 &lt;&lt; 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> base 233</span></span><br><span class="line">ll mod = inf;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">myHash</span><span class="params">(<span class="keyword">char</span> s[])</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        res = (base * res + (ll)s[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在很大的问题就是服务器数量相当于mod，数量有改变mod改变，整个hash就乱套了，于是乎有了Consistent Hash，这里不详细解释，这里讲的是Google的Jump Consistent Hash，8行代码，短小精悍。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">JumpConsistentHash</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">int32_t</span> num_buckets)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int64_t</span> b = <span class="number">-1</span>, j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; num_buckets) &#123;  </span><br><span class="line">        b = j;  </span><br><span class="line">        key = key * <span class="number">2862933555777941757ULL</span> + <span class="number">1</span>;  </span><br><span class="line">        j = (b + <span class="number">1</span>) * (<span class="built_in"><span class="keyword">double</span></span>(<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>) / <span class="built_in"><span class="keyword">double</span></span>((key &gt;&gt; <span class="number">33</span>) + <span class="number">1</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> b;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么一看你肯定是懵逼了，我一步步来解释。<br>这里先令f(key, n)为一致性哈希算法,输出的为[0,n)之间的数字，代表数据在对应的节点上。</p>
<p>1.n=1时，对于任意的key，输出应该都是0。（比如你有1个服务器，那么就是无论如何都是分配到这个服务器上）<br>2.n=2时，负载均衡，应该有1/2的结果保持为0，1/2的结果输出为1。<br>3.n=3时，负载均衡，应该有1/3的结果保持为0，1/3的结果保持为1，1/3的结果保持为2。<br>4.依次递推，节点数由n变为n+1时，f(key, n)里面应该有n/(n+1)的结果不变。<br>结论：<br><strong>有1/(n+1)的结果变为n</strong></p>
<p>如下图，有个重要的规律，在某条不跳变的路径上，数值是一样的。</p>
<p>这个使用概率公式来表示，就是这样的代码，于是我们可以得到下面这个<strong>ch</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> num_buckets)</span> </span>&#123;  </span><br><span class="line">    random.<span class="built_in">seed</span>(key) ;  </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>; <span class="comment">// This will track ch(key, j +1) .  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; num_buckets; j ++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (random.<span class="built_in">next</span>() &lt; <span class="number">1.0</span>/(j+<span class="number">1</span>) ) b = j ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> b;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加一个节点后，一个固定的key输出的结果发生了改变。快速计算出这个固定的key在哪些节点下发生了改变，就可以快速计算出最终答案，就是Jump Consistent Hash的思路。<br>假设某一次结果是b，经过若干次概率测试，下一次改变为a，则从b到a-1这中间，不管节点如何变化，这个key的结果都是不会变化的。<br>根据上一小节的到的概率变化公式，新增一个节点数字不变化的概率是n/(n+1)。<br>那从b到i不变化的概率就是b/i（中间的抵消了）<br>设有随机函数r，当r小于b/i时，f(i)=f(b)。那么i的上界就是(b+1)/r。<br>这个上限也是下一次key发生变化的节点数量，由此可以得出下面的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ch</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> num_buckets)</span> </span>&#123;  </span><br><span class="line">    random. <span class="built_in">seed</span>(key) ;  </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">-1</span>; <span class="comment">//  bucket number before the previous jump  </span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// bucket number before the current jump  </span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;num_buckets)&#123;  </span><br><span class="line">        b=j;  </span><br><span class="line">        <span class="keyword">double</span> r=random.<span class="built_in">next</span>(); <span class="comment">//  0&lt;r&lt;1.0  </span></span><br><span class="line">        j = <span class="built_in">floor</span>( (b+<span class="number">1</span>) /r);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> b;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于r是均匀的，所以期望是1/2。<br>这样，代码中j就是按照指数级增长的，平均复杂度就是O(log(n))了。</p>
<p>回头看看第一个代码，就可以看懂代码了。</p>
<p>第一个key=key*x+1算是一个伪随机生成器。<br>而j=(b+1)*x/y则是上面的求上界的公式，其中y/x通过浮点数运算来产生(0,1)内的一个随机数。</p>
<p>我们可以发现一开始的代码是没有random. seed的，因为用了线性同余</p>
]]></content>
  </entry>
  <entry>
    <title>gcc/g++小入门</title>
    <url>/2021/05/06/gcc-g-%E5%B0%8F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>目录结构如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ tree</span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── func.h</span><br><span class="line">├── main.cpp</span><br><span class="line">└── src</span><br><span class="line">    └── func.cpp</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>func.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ g++ main.cpp src/func.cpp -Iinclude -o a.out</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ g++ main.cpp src/func.cpp -Iinclude -Wall -std=c++11 -o b.out</span><br></pre></td></tr></table></figure>

<p>生成func的静态库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cd</span> src</span><br><span class="line"><span class="comment"># 汇编生成func.o</span></span><br><span class="line">❯ g++ func.cpp -c -I../include</span><br><span class="line"><span class="comment"># 生成静态链接库libFunc.a</span></span><br><span class="line">❯ ar rs libFunc.a func.o</span><br><span class="line">ar: creating archive libFunc.a</span><br><span class="line"><span class="comment"># 使用静态库g编译生成static.out</span></span><br><span class="line">❯ <span class="built_in">cd</span> ..</span><br><span class="line">❯ g++ main.cpp -lfunc -Lsrc -Iinclude -o static.out</span><br></pre></td></tr></table></figure>

<p>生成func的动态库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">cd</span> src</span><br><span class="line"><span class="comment"># 生成动态库libfunc.so</span></span><br><span class="line">❯ g++ func.cpp -I../include -fPIC -shared -o libfunc.so</span><br><span class="line"><span class="comment"># 使用动态库g编译生成dynamic.out</span></span><br><span class="line">g++ main.cpp -Iinclude -lfunc -Lsrc -o dynamic</span><br><span class="line"><span class="comment"># 运行dynamic</span></span><br><span class="line">DYLD_LIBRARY_PATH=src ./dynamic <span class="comment"># for MacOS</span></span><br><span class="line">LD_LIBRARY_PATH=src ./dynamic   <span class="comment"># for Linux</span></span><br></pre></td></tr></table></figure>

<h2 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h2><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">		sum += i;</span><br><span class="line">		i += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ g++ -g gdbMain.cpp -o gdbMain</span><br><span class="line">❯ gdb gdbMain</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>iOS开发:本地化适配</title>
    <url>/2021/10/02/iOS%E5%BC%80%E5%8F%91-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<hr>
<p>关于iOS开发中本地化适配技巧</p>
<span id="more"></span>
<p>一般先在project-&gt;info页面配置需要本地化的语言</p>
<img src="/2021/10/02/iOS%E5%BC%80%E5%8F%91-%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%80%82%E9%85%8D/iOS%E5%BC%80%E5%8F%91_%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%80%82%E9%85%8D_1.jpg" class="" title="iOS开发_本地化适配_1">

<p>然后会弹窗需要适配的storyboard，点选是之后会出现和storyboard同名的.stringts文件，以ObjectID为key逐个适配text文本，但是这种方式在xcode不能做到随改随更新，brew install bartycrouch这个插件可以搞定。</p>
<p>其他代码中文本的适配可以创建Localizable.strings文件（名字不能错）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在需要文本的代码写上</span></span><br><span class="line"><span class="type">NSLocalizedString</span>(<span class="string">&quot;Home&quot;</span>, comment: <span class="string">&quot;comment是注释而已&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Localizable文件写本地化翻译，这个文件右边配置面板可勾选语言</span></span><br><span class="line"><span class="string">&quot;Home&quot;</span> <span class="operator">=</span> <span class="string">&quot;主页&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>c/c++多线程和线程同步</title>
    <url>/2021/05/02/c-c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<hr>
<p>文章还没写完呢</p>
<span id="more"></span>

<h1 id="c-c-线程的使用"><a href="#c-c-线程的使用" class="headerlink" title="c/c++线程的使用"></a>c/c++线程的使用</h1><p>编译-l指定动态链接库pthread</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc xxx.c -lpthread -o xxx </span><br></pre></td></tr></table></figure>

<h2 id="1-线程创建"><a href="#1-线程创建" class="headerlink" title="1.线程创建"></a>1.线程创建</h2><p>pthread_t是long类型的线程id<br>pthread_create时callback调用子线程执行的函数，第四个参数是callback传入的void* arg<br>sleep让子线程执行完再挂断主线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;子线程i=: %d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子线程id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;主线程i=: %d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;主线程id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-线程退出"><a href="#2-线程退出" class="headerlink" title="2.线程退出"></a>2.线程退出</h2><p>主线程退出，子线程变主，回收空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;子线程i=: %d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子线程id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//for (int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line">	<span class="comment">//	printf(&quot;主线程i=: %d\n&quot;, i);</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;主线程id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">	<span class="comment">//sleep(1);</span></span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-线程回收"><a href="#3-线程回收" class="headerlink" title="3.线程回收"></a>3.线程回收</h2><p>join会让主线程阻塞<br>接受个Test的struct作为资源<br>直接在子线程开struct Test t会开在栈空间，回收后释放了，主线程肯定拿不到这个资源<br>要么：struct Test t开在全局变量，join后拿到Test，然后强转下struct Test* pt = (struct Test*)ptr;<br>要么：在主线程里开struct Test t，然后pthread_join(tid, &amp;ptr)给子线程，子线程在arg拿到，也要强转下struct Test* t = (struct Test*)arg</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct Test t; //开在这里</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;子线程i=: %d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子线程id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Test</span>* <span class="title">t</span> =</span> (struct Test*)arg;</span><br><span class="line">	t-&gt;num = <span class="number">100</span>;</span><br><span class="line">	t-&gt;age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">	pthread_exit(&amp;t); <span class="comment">//Test t如果是在子线程中开栈空间后会被释放</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span> <span class="comment">//或者开在这里</span></span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, &amp;t);</span><br><span class="line">	<span class="comment">//for (int i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line">	<span class="comment">//	printf(&quot;主线程i=: %d\n&quot;, i);</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;主线程id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">	<span class="comment">//sleep(1);</span></span><br><span class="line">	<span class="comment">//pthread_exit(NULL);</span></span><br><span class="line">	<span class="keyword">void</span>* ptr;</span><br><span class="line">	pthread_join(tid, &amp;ptr);</span><br><span class="line">	<span class="comment">//struct Test* pt = (struct Test*)ptr;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%主线程: pt.num=%d, pt.age=%d\n&quot;</span>, t.num, t.age);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-线程分离"><a href="#4-线程分离" class="headerlink" title="4.线程分离"></a>4.线程分离</h2><p>让主线程退出后不会释放子线程的资源<br>这里子线程创建后和主线程分离，子线程死后由内核调度回收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;子线程i=: %d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子线程id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Test</span>* <span class="title">t</span> =</span> (struct Test*)arg;</span><br><span class="line">	t-&gt;num = <span class="number">100</span>;</span><br><span class="line">	t-&gt;age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">	pthread_exit(&amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span> <span class="comment">//或者开在这里</span></span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, &amp;t);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;主线程id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">	pthread_detach(tid);</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-其他线程函数"><a href="#5-其他线程函数" class="headerlink" title="5.其他线程函数"></a>5.其他线程函数</h3><p>pthread_cancel退出子线程，但是会在系统调用之后（printf就是）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">callback</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;子线程i=: %d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;子线程id: %ld\n&quot;</span>, pthread_self()); <span class="comment">//printf系统调用了</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Test</span>* <span class="title">t</span> =</span> (struct Test*)arg;</span><br><span class="line">	t-&gt;num = <span class="number">100</span>;</span><br><span class="line">	t-&gt;age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">	pthread_exit(&amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span> <span class="comment">//或者开在这里</span></span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, &amp;t);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;主线程id: %ld\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">	pthread_detach(tid);</span><br><span class="line">	pthread_cancel(tid); <span class="comment">//杀死子进程</span></span><br><span class="line"></span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>); <span class="comment">//主线程退出</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="c-c-线程的同步和互斥锁"><a href="#c-c-线程的同步和互斥锁" class="headerlink" title="c/c++线程的同步和互斥锁"></a>c/c++线程的同步和互斥锁</h1><h3 id="不同步"><a href="#不同步" class="headerlink" title="不同步"></a>不同步</h3><p>很明显这没有同步，最后不是100</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>; <span class="comment">//全局资源</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">funcA</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> cur = number;</span><br><span class="line">		cur++;</span><br><span class="line">		usleep(<span class="number">10</span>);</span><br><span class="line">		number = cur;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">funcB</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> cur = number;</span><br><span class="line">		cur++;</span><br><span class="line">		number = cur;</span><br><span class="line">		usleep(<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 阻塞 &amp; 回收</span></span><br><span class="line">	pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>锁：状态（锁/没锁）；加锁信息（线程id）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>; <span class="comment">//全局资源</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">funcA</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		<span class="keyword">int</span> cur = number;</span><br><span class="line">		cur++;</span><br><span class="line">		usleep(<span class="number">10</span>);</span><br><span class="line">		number = cur;</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">funcB</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		<span class="keyword">int</span> cur = number;</span><br><span class="line">		cur++;</span><br><span class="line">		number = cur;</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">		usleep(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> p1, p2;</span><br><span class="line"></span><br><span class="line">	pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 阻塞 &amp; 回收</span></span><br><span class="line">	pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>lc206:ReverseLinkedList一些乱七八糟的解法</title>
    <url>/2020/08/09/lc206-ReverseLinkedList%E4%B8%80%E4%BA%9B%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p><strong>Example:</strong></p>
<p>“<code> Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL “</code></p>
<p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//循环（开空间）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode temp = <span class="keyword">new</span> ListNode(head.val);</span><br><span class="line">            temp.next = dummy;</span><br><span class="line">            dummy = temp;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环（不开空间）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">null</span>, cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = dummy;</span><br><span class="line">            dummy = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>lc奇奇怪怪的搜索（无营养的🐟）</title>
    <url>/2020/08/22/lc%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E6%90%9C%E7%B4%A2%EF%BC%88%E6%97%A0%E8%90%A5%E5%85%BB%E7%9A%84%F0%9F%90%9F%EF%BC%89/</url>
    <content><![CDATA[<hr>
<p>lc的dfs和bfs合集</p>
<span id="more"></span>

<h5 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        n = board.length;</span><br><span class="line">        m = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>) &amp;&amp; bfs(i, j, <span class="number">0</span>, board, word)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index, <span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m || board[i][j] != word.charAt(index)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index, <span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!check(i, j, index, board, word)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = bfs(i-<span class="number">1</span>, j, index+<span class="number">1</span>, board, word) ||</span><br><span class="line">                      bfs(i+<span class="number">1</span>, j, index+<span class="number">1</span>, board, word) ||</span><br><span class="line">                      bfs(i, j+<span class="number">1</span>, index+<span class="number">1</span>, board, word) ||</span><br><span class="line">                      bfs(i, j-<span class="number">1</span>, index+<span class="number">1</span>, board, word);</span><br><span class="line">        board[i][j] = temp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="695-Max-Area-of-Island"><a href="#695-Max-Area-of-Island" class="headerlink" title="695. Max Area of Island"></a>695. Max Area of Island</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n = grid.length;</span><br><span class="line">        m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[i][j] || grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    area = <span class="number">0</span>;</span><br><span class="line">                    dfs(i, j, grid, vis);</span><br><span class="line">                    res = Math.max(area, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] vis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m || vis[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] vis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!check(i, j, grid, vis)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            vis[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        area += <span class="number">1</span>;</span><br><span class="line">        dfs(i+<span class="number">1</span>, j, grid, vis);</span><br><span class="line">        dfs(i-<span class="number">1</span>, j, grid, vis);</span><br><span class="line">        dfs(i, j+<span class="number">1</span>, grid, vis);</span><br><span class="line">        dfs(i, j-<span class="number">1</span>, grid, vis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a>200. Number of Islands</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n = grid.length;</span><br><span class="line">        m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    dfs(i, j, grid);</span><br><span class="line">                    res += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!check(i, j, grid)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(i+<span class="number">1</span>, j, grid);</span><br><span class="line">        dfs(i-<span class="number">1</span>, j, grid);</span><br><span class="line">        dfs(i, j+<span class="number">1</span>, grid);</span><br><span class="line">        dfs(i, j-<span class="number">1</span>, grid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="547-Friend-Circles"><a href="#547-Friend-Circles" class="headerlink" title="547. Friend Circles"></a>547. Friend Circles</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        n = M.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">                dfs(M, vis, i);</span><br><span class="line">                res += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">boolean</span>[] vis, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] == <span class="number">1</span> &amp;&amp; !vis[j]) &#123;</span><br><span class="line">                dfs(M, vis, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>关于光线追踪:下一周的球体uv坐标</title>
    <url>/2021/05/10/%E5%85%B3%E4%BA%8E%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA-%E4%B8%8B%E4%B8%80%E5%91%A8%E7%9A%84%E7%90%83%E4%BD%93uv%E5%9D%90%E6%A0%87/</url>
    <content><![CDATA[<hr>
<p>文章更新中</p>
<span id="more"></span>

<p>就是文中这段代码的三角函数部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSphereUV</span><span class="params">(<span class="keyword">const</span> point3&amp; p, <span class="keyword">double</span>&amp; u, <span class="keyword">double</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p: a given point on the sphere of radius one, centered at the origin.</span></span><br><span class="line">    <span class="comment">// u: returned value [0,1] of angle around the Y axis from X=-1.</span></span><br><span class="line">    <span class="comment">// v: returned value [0,1] of angle from Y=-1 to Y=+1.</span></span><br><span class="line">    <span class="comment">//     &lt;1 0 0&gt; yields &lt;0.50 0.50&gt;       &lt;-1  0  0&gt; yields &lt;0.00 0.50&gt;</span></span><br><span class="line">    <span class="comment">//     &lt;0 1 0&gt; yields &lt;0.50 1.00&gt;       &lt; 0 -1  0&gt; yields &lt;0.50 0.00&gt;</span></span><br><span class="line">    <span class="comment">//     &lt;0 0 1&gt; yields &lt;0.25 0.50&gt;       &lt; 0  0 -1&gt; yields &lt;0.75 0.50&gt;</span></span><br><span class="line">    <span class="keyword">auto</span> theta = <span class="built_in">acos</span>(-p.<span class="built_in">y</span>());</span><br><span class="line">    <span class="keyword">auto</span> phi = <span class="built_in">atan2</span>(-p.<span class="built_in">z</span>(), p.<span class="built_in">x</span>()) + pi;</span><br><span class="line"></span><br><span class="line">    u = phi / (<span class="number">2</span>*pi);</span><br><span class="line">    v = theta / pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四章没有配图，一开始我也没看懂uv坐标，自己画画图就好了</p>
]]></content>
  </entry>
  <entry>
    <title>前序/中序遍历还原二叉树</title>
    <url>/2019/03/13/%E5%89%8D%E5%BA%8F-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<img src="/2019/03/13/%E5%89%8D%E5%BA%8F-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%89%8D%E5%BA%8F-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91_1.jpg" class="" title="前序-中序遍历还原二叉树_1">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="keyword">int</span> in[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> date;</span><br><span class="line">    node *left_child;</span><br><span class="line">    node *right_child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node *root = <span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;date = pre[preL];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = inL; i &lt;= inR; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == root-&gt;date)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left_len = i - inL;</span><br><span class="line">    root-&gt;left_child = <span class="built_in">create</span>(preL+<span class="number">1</span>, preR+left_len, inL, i<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right_child = <span class="built_in">create</span>(preL+left_len+<span class="number">1</span>+<span class="number">1</span>, preR, i+<span class="number">1</span>, inR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>力扣34</title>
    <url>/2019/05/26/%E5%8A%9B%E6%89%A334/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="力扣34"><a href="#力扣34" class="headerlink" title="力扣34"></a>力扣34</h1><p>二分的很好的应用。<br>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).<br>可以看到二分的前半段可能是两次或一次递增<br>如果target &gt; nums[start] 并且 target &lt; nums[mid]，那么target在前半部分。 后半部分同理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span>&lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (end - start)/<span class="number">2</span> + start;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[start] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[start] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;</span><br><span class="line">                    end = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    start = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; target &lt;= nums[end]) &#123;</span><br><span class="line">                    start = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    end = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[end] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>奇奇怪怪的二分（无营养摸🐟文）</title>
    <url>/2020/08/18/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E4%BA%8C%E5%88%86%EF%BC%88%E6%97%A0%E8%90%A5%E5%85%BB%E6%91%B8%F0%9F%90%9F%E6%96%87%EF%BC%89/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="奇奇怪怪的二分（无营养摸🐟文）"><a href="#奇奇怪怪的二分（无营养摸🐟文）" class="headerlink" title="奇奇怪怪的二分（无营养摸🐟文）"></a>奇奇怪怪的二分（无营养摸🐟文）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= key) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; key) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= key) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; key) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">upper_bound2</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= v) l = m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[m] &gt; v) r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(lower_bound(nums, <span class="number">2</span>));</span><br><span class="line">        System.out.println(upper_bound(nums, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>实现一个简单neural networks</title>
    <url>/2019/10/09/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95neural-networks/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p><a href="https://github.com/haoboxuxu/Tensorflow-Theory/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/9_%E6%89%8B%E5%86%99%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.py">源代码</a><br>先定义一些数据，X和y</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">y = np.array([[<span class="number">0</span>],</span><br><span class="line">              [<span class="number">1</span>],</span><br><span class="line">              [<span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>]])</span><br></pre></td></tr></table></figure>

<p>然后是sigmoid激活函数，deriv true是前向传播，就是常见的sigmoid，deriv false为反向传播，就是sigmoid求导的结果，如果不明白为什么是x*(1-x)，可以看如下的求导，这里的x是sigmoid(x)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">x, deriv=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> deriv == <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">return</span> x * (<span class="number">1</span> - x)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br></pre></td></tr></table></figure>

<img src="/2019/10/09/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95neural-networks/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95neural-networks_1.jpg" class="" title="实现一个简单neural-networks_1">

<p>做一个两层的nn，这里的w0和w1映射到（-1，1），所以做了<em>2和+1操作，注意维度，w0是和X相乘，w1是和（w0</em>X）结果相乘。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w0 = <span class="number">2</span> * np.random.random((<span class="number">3</span>, <span class="number">4</span>)) - <span class="number">1</span></span><br><span class="line">w1 = <span class="number">2</span> * np.random.random((<span class="number">4</span>, <span class="number">1</span>)) - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>然后我们迭代一下，这里的l1和l2是正向，需要sigmoid。然后loss就是y – l2<br>l2_delta是反向，这里求导，l1_error和最后的loss是同理的，这两个sigmoid传入都是false。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50000</span>):</span><br><span class="line">    l0 = X</span><br><span class="line">    l1 = sigmoid(np.dot(l0, w0))</span><br><span class="line">    l2 = sigmoid(np.dot(l1, w1))</span><br><span class="line"></span><br><span class="line">    l2_error = y - l2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j % <span class="number">100</span>) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;err = &quot;</span> + <span class="built_in">str</span>(np.mean(np.<span class="built_in">abs</span>(l2_error))))</span><br><span class="line"></span><br><span class="line">    l2_delta = l2_error * sigmoid(l2, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    l1_error = l2_delta.dot(w1.T)</span><br><span class="line">    l1_delta = l1_error * sigmoid(l1, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    w1 += l1.T.dot(l2_delta)</span><br><span class="line">    w0 += l0.T.dot(l1_delta)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>我的博客好像坏了</title>
    <url>/2021/10/04/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A5%BD%E5%83%8F%E5%9D%8F%E4%BA%86/</url>
    <content><![CDATA[<p>呜呜呜</p>
]]></content>
  </entry>
  <entry>
    <title>力扣23</title>
    <url>/2019/04/25/%E5%8A%9B%E6%89%A323/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="力扣23"><a href="#力扣23" class="headerlink" title="力扣23"></a>力扣23</h1><p>hard，k路有序list合并，分治思想，mergesort类似 O(nlogk)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> sort(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sort</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[low];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">        ListNode l1 = sort(lists, low, mid);</span><br><span class="line">        ListNode l2 = sort(lists, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (l1 == null)</span></span><br><span class="line"><span class="comment">            return l2;</span></span><br><span class="line"><span class="comment">        if (l2 == null)</span></span><br><span class="line"><span class="comment">            return l1;</span></span><br><span class="line"><span class="comment">        if (l1.val &lt; l2.val) &#123;</span></span><br><span class="line"><span class="comment">            l1.next = merge(l1.next, l2);</span></span><br><span class="line"><span class="comment">            return l1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        l2.next = merge(l1, l2.next);</span></span><br><span class="line"><span class="comment">        return l2;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ListNode temp = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode runner = temp;;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                runner.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                runner = runner.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                runner.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                runner = runner.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            runner.next = l2;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            runner.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2路——merge</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = L, j = M + <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)malloc((R - L + <span class="number">1</span>) * sizeof(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= M &amp;&amp; j &lt;= R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt;= A[j])&#123;</span><br><span class="line">            temp[index++] = A[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            temp[index++] = A[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= M)&#123;</span><br><span class="line">        temp[index++] = A[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= R)&#123;</span><br><span class="line">        temp[index++] = A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">        A[L + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(A, left, mid);</span><br><span class="line">        merge_sort(A, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(A, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    merge_sort(A, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; A[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>树的各种遍历</title>
    <url>/2020/05/07/%E6%A0%91%E7%9A%84%E5%90%84%E7%A7%8D%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h5 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeTraverse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;TreeNode&gt; preList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;TreeNode&gt; inList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;TreeNode&gt; postList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        preList.add(root);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preOrder(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            preOrder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inOrder(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        inList.add(root);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inOrder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postOrder(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postOrder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        postList.add(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode node1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        TreeNode node2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        TreeNode node3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        TreeNode node4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        node1.left = node2;</span><br><span class="line">        node1.right = node3;</span><br><span class="line">        node3.left = node4;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;前序&quot;</span>);</span><br><span class="line">        preOrder(node1);</span><br><span class="line">        <span class="keyword">for</span> (TreeNode node : preList) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;中序&quot;</span>);</span><br><span class="line">        inOrder(node1);</span><br><span class="line">        <span class="keyword">for</span> (TreeNode node : inList) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;后序&quot;</span>);</span><br><span class="line">        postOrder(node1);</span><br><span class="line">        <span class="keyword">for</span> (TreeNode node : postList) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeTraverse2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;TreeNode&gt; preList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;TreeNode&gt; inList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;TreeNode&gt; postList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                preList.add(root);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                inList.add(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 非递归后序遍历 思路:要保证根结点在其左孩子和右孩子访问之后才能访问,因此对于任一结点p,先将其入栈.</span></span><br><span class="line"><span class="comment">     * 如果p不存在左孩子和右孩子,则可直接访问;否则将p的右孩子和左孩子依次入栈然后把p的左右孩子结点赋值null,这样就保证了每次取栈顶的元素的时候</span></span><br><span class="line"><span class="comment">     * 左孩子在右孩子前面被访问, 左孩子和右孩子都在根结点前面被访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> tag = <span class="keyword">true</span>;</span><br><span class="line">            TreeNode preNode = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; tag == <span class="keyword">true</span>) &#123;</span><br><span class="line">                root = stack.peek();</span><br><span class="line">                <span class="keyword">if</span> (root.right == preNode) &#123;</span><br><span class="line">                    root = stack.pop();</span><br><span class="line">                    postList.add(root);</span><br><span class="line">                    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        preNode = root;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    root = root.right;</span><br><span class="line">                    tag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode node1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        TreeNode node2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        TreeNode node3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        TreeNode node4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        node1.left = node2;</span><br><span class="line">        node1.right = node3;</span><br><span class="line">        node3.left = node4;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;前序&quot;</span>);</span><br><span class="line">        preOrder(node1);</span><br><span class="line">        <span class="keyword">for</span> (TreeNode node : preList) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;中序&quot;</span>);</span><br><span class="line">        inOrder(node1);</span><br><span class="line">        <span class="keyword">for</span> (TreeNode node : inList) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;后序&quot;</span>);</span><br><span class="line">        postOrder(node1);</span><br><span class="line">        <span class="keyword">for</span> (TreeNode node : postList) &#123;</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="补：层次遍历非递归"><a href="#补：层次遍历非递归" class="headerlink" title="补：层次遍历非递归"></a>补：层次遍历非递归</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = q.poll();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) q.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2来自序列化题中（不用分层）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = q.remove();</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">            str += <span class="string">&quot;null,&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str += cur.val + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            q.add(cur.left);</span><br><span class="line">            q.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>树除遍历外的一些骚（最后的🐟）</title>
    <url>/2020/08/27/%E6%A0%91%E9%99%A4%E9%81%8D%E5%8E%86%E5%A4%96%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AA%9A%EF%BC%88%E6%9C%80%E5%90%8E%E7%9A%84%F0%9F%90%9F%EF%BC%89/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h5 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a>100. Same Tree</h5><pre><code> 判断俩树是不是一样的
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span> || p == <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h5><pre><code> 判断一个树是不是对称的
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> checkLR(root.left, root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkLR</span><span class="params">(TreeNode l, TreeNode r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span> &amp;&amp; r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span> &amp;&amp; l.val == r.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkLR(l.left, r.right) &amp;&amp; checkLR(l.right, r.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h5><pre><code>翻转一个二叉树
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        swapTreeNodes(root, left, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapTreeNodes</span><span class="params">(TreeNode root, TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a>235. Lowest Common Ancestor of a Binary Search Tree</h5><pre><code> 二叉树(有序)的LCA
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h5><pre><code> 二叉树(无序)的LCA
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right != <span class="keyword">null</span> ? right : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>美妙的随机数和宇宙🌌</title>
    <url>/2021/04/21/%E7%BE%8E%E5%A6%99%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%92%8C%E5%AE%87%E5%AE%99%F0%9F%8C%8C/</url>
    <content><![CDATA[<hr>
<p>最近的交了WWDC2021作品，然后我凑巧通过伪随机数生成一个SkyBox，说一下思路嘿嘿</p>
<span id="more"></span>

<h5 id="最近的交了WWDC2021作品，然后我凑巧通过伪随机数生成一个SkyBox，说一下思路嘿嘿"><a href="#最近的交了WWDC2021作品，然后我凑巧通过伪随机数生成一个SkyBox，说一下思路嘿嘿" class="headerlink" title="最近的交了WWDC2021作品，然后我凑巧通过伪随机数生成一个SkyBox，说一下思路嘿嘿"></a>最近的交了WWDC2021作品，然后我凑巧通过伪随机数生成一个SkyBox，说一下思路嘿嘿</h5><p>然后这篇文主要是写给有了解过Ray Tracing in one weekend看的<br>下面代码都是Metal<br>这个随机书算法是从StackOverflow拿过来的，日常CV嘿嘿，但是原回答没说怎么用，这几我姑且把x和y算作屏幕像素的texturecoord的x和y<br>z是从CPU那边buffer过来的时钟信号，主要是每一帧能z+1就好了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generate a random float in the range [0.0f, 1.0f] using x, y, and z (based on the xor128 algorithm)</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">randomer_gen_float</span><span class="params">(thread <span class="keyword">const</span> uint2&amp; position, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seed = position.x + position.y * <span class="number">57</span> + z * <span class="number">241</span>;</span><br><span class="line">    seed= (seed&lt;&lt; <span class="number">13</span>) ^ seed;</span><br><span class="line">    <span class="keyword">return</span> (( <span class="number">1.0</span> - ( (seed * (seed * seed * <span class="number">15731</span> + <span class="number">789221</span>) + <span class="number">1376312589</span>) &amp; <span class="number">2147483647</span>) / <span class="number">1073741824.0f</span>) + <span class="number">1.0f</span>) / <span class="number">2.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里写了一个SkyBox的Material，参数什么的姑且不看，<br>主要是c：和原书中生成天空渐变色一样<br>     float rd是vec3的三维随机数，别忘了z要+1、+2，不然一个像素内的时间种子z是一样的<br>     pow是滤波，需要把rd中偏向灰白色的像素过滤掉，只留下发亮的星星✨，把✨给我们的star，然后SkyBox这支Material会反射回去</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkyBox</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SkyBox</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">radiate</span><span class="params">(thread <span class="keyword">const</span> Ray&amp; r_in,</span></span></span><br><span class="line"><span class="function"><span class="params">                 thread <span class="keyword">const</span> HitRecord&amp; rec,</span></span></span><br><span class="line"><span class="function"><span class="params">                 thread float3&amp; attenuation,</span></span></span><br><span class="line"><span class="function"><span class="params">                 thread Ray&amp; radiated,</span></span></span><br><span class="line"><span class="function"><span class="params">                 thread <span class="keyword">const</span> uint2&amp; position, <span class="keyword">float</span> seed)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        float3 unit_direction = <span class="built_in">unit_vector</span>(r_in.<span class="built_in">direction</span>());</span><br><span class="line">        <span class="keyword">float</span> t = <span class="number">0.9f</span>*(unit_direction.y + <span class="number">1.0f</span>);</span><br><span class="line">        float3 c = (<span class="number">1.0f</span>-t)*<span class="built_in">float3</span>(<span class="number">0.53</span>, <span class="number">0.5</span>, <span class="number">0.4</span>) + t*<span class="built_in">float3</span>(<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.05</span>); <span class="comment">// space background</span></span><br><span class="line">        <span class="keyword">float</span> gradient = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">float</span> rd = <span class="built_in">pow</span>(<span class="built_in">randomer_gen_float</span>(<span class="built_in">uint2</span>(gradient*<span class="built_in">abs</span>(rec.p.x), gradient*<span class="built_in">abs</span>(rec.p.y)), gradient*<span class="built_in">abs</span>(rec.p.x+rec.p.y+rec.p.z)), <span class="number">1000</span>);</span><br><span class="line">        float3 star = <span class="built_in">float3</span>(rd, rd, rd<span class="number">-0.01</span>);</span><br><span class="line">        float3 reflected = <span class="built_in">reflect</span>(<span class="built_in">unit_vector</span>(r_in.<span class="built_in">direction</span>()), rec.normal);</span><br><span class="line">        radiated = <span class="built_in">Ray</span>(rec.p, reflected);</span><br><span class="line">        attenuation = star + c;</span><br><span class="line">        attenuation *= <span class="number">2.5</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">dot</span>(radiated.<span class="built_in">direction</span>(), rec.normal) &lt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后就是因为这支SkyBox是天空盒，相机在里面，需要把反射的方向取个反，这行代码所在位置相当于书里的ray_color里，我的写法里的cur_ray是去掉了递归，循环的写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cur_ray = <span class="built_in">Ray</span>(radiated.orig, -radiated.<span class="built_in">direction</span>());</span><br></pre></td></tr></table></figure>
<h5 id="看看效果咯"><a href="#看看效果咯" class="headerlink" title="看看效果咯"></a>看看效果咯</h5><img src="/2021/04/21/%E7%BE%8E%E5%A6%99%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%92%8C%E5%AE%87%E5%AE%99%F0%9F%8C%8C/%E7%BE%8E%E5%A6%99%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%92%8C%E5%AE%87%E5%AE%99%F0%9F%8C%8C_1.jpg" class="" title="美妙的随机数和宇宙🌌_1">]]></content>
  </entry>
  <entry>
    <title>背包问题（01完全多重）</title>
    <url>/2019/03/12/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%8801%E5%AE%8C%E5%85%A8%E5%A4%9A%E9%87%8D%EF%BC%89/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="背包问题（01-完全-多重）"><a href="#背包问题（01-完全-多重）" class="headerlink" title="背包问题（01/完全/多重）"></a>背包问题（01/完全/多重）</h1><p>背包问题是动态规划里经典的问题：就我个人理解，动态规划是一种与上一个状态相关的算法，而且每一个字问题有类似的选和不选的状态，会影响上一个状态，整个递归的状态是类似树的结构，如递归的斐波那契。</p>
<p>01背包：有N种物品和一个容量为V的背包，每种物品只有一个。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<p>这个是最基本的背包问题，每一个子状态只有选和不选，可以递归求解，但这样开销是2^n,可以用滚动数组优化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[maxn], c[maxn], n[maxn];<span class="comment">//价值，体积，个数</span></span><br><span class="line"><span class="keyword">int</span> N;<span class="comment">//物品个数</span></span><br><span class="line"><span class="keyword">int</span> V;<span class="comment">//背包体积</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero_one</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;<span class="comment">//枚举N个物体</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= c[i]; j--)&#123;<span class="comment">//背包容量到第I个物品的费用，一定要递减</span></span><br><span class="line">           <span class="comment">//这样意思是j容量情况下的背包在放/不放ci个物品求最大价值</span></span><br><span class="line">           dp[j] = <span class="built_in">max</span>(dp[j], dp[j - c[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完全背包：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[maxn], c[maxn], n[maxn];<span class="comment">//价值，体积，个数</span></span><br><span class="line"><span class="keyword">int</span> N;<span class="comment">//物品个数</span></span><br><span class="line"><span class="keyword">int</span> V;<span class="comment">//背包体积</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = c[i]; j &lt;= V; j++)&#123;</span><br><span class="line">            <span class="comment">//这里用递减就可以渠道不止一次ci件物品，只要不超过V</span></span><br><span class="line">            <span class="comment">//只是01的倒过来</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - c[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多重背包：有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<p>这里用了一个巧妙的思想转化为01背包问题。</p>
<p>假如给了价值为2，但是数量10的物品，应该把10进行二进制拆分，所以10就是可以有1，2, 4，8之内的数把它组成，一开始选1，然后10-1=9，再选上,然后9-2=7，再选4,然后7-4=3，结果：10由 1,2,4,3组成<br>结果：价值为2，数量是10的这批货物，转化成了价值分别是2,4,6,8元的货物了而且只有一个，这就是二进制优化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[maxn], c[maxn], n[maxn];<span class="comment">//价值，体积，个数</span></span><br><span class="line"><span class="keyword">int</span> N;<span class="comment">//物品个数</span></span><br><span class="line"><span class="keyword">int</span> V;<span class="comment">//背包体积</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiple</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n[i]; n[i] -= k, k&lt;&lt;=<span class="number">1</span>)&#123;<span class="comment">//k左移</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= k*c[i]; j--)&#123;</span><br><span class="line">                <span class="comment">//每次变为k个质量ci物品</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - k*c[i]] + k*w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一层01</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = V; j &gt;= n[i]*c[i]; j--)&#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - n[i]*c[i]] + n[i]*w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
